generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Project {
  id                String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name              String              @db.VarChar(255)
  createdAt         DateTime            @default(now()) @map("created_at") @db.Timestamp()
  updatedAt         DateTime            @default(now()) @map("updated_at") @db.Timestamp()
  deletedAt         DateTime?           @map("deleted_at") @db.Timestamp()
  appUsers          AppUser[]
  user              User                @relation(fields: [userId], references: [id])
  userId            String              @map("user_id") @db.Uuid
  projectAuthTokens ProjectAuthTokens[]

  @@map("projects")
}

model AppUser {
  userIdentifier String          @id @map("user_identifier") @db.VarChar(255)
  projectId      String          @map("project_id") @db.Uuid
  createdAt      DateTime        @default(now()) @map("created_at") @db.Timestamp()
  deletedAt      DateTime?       @map("deleted_at") @db.Timestamp()
  project        Project         @relation(fields: [projectId], references: [id])
  deviceChanges  DeviceChanges[]
  devices        Device[]

  @@map("app_users")
}

model Device {
  deviceId       String          @map("device_id") @db.VarChar(255)
  userIdentifier String          @map("user_identifier") @db.VarChar(255)
  lastSeenAt     DateTime?       @map("last_seen_at") @db.Timestamp()
  lastChangeAt   DateTime?       @map("last_change_at") @db.Timestamp()
  createdAt      DateTime        @default(now()) @map("created_at") @db.Timestamp()
  deletedAt      DateTime?       @map("deleted_at") @db.Timestamp()
  appUser        AppUser         @relation(fields: [userIdentifier], references: [userIdentifier])
  deviceChanges  DeviceChanges[]

  @@id([deviceId, userIdentifier])
  @@map("devices")
}

enum ChangeType {
  CREATE
  UPDATE
  DELETE
}

model DeviceChanges {
  id              String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userIdentifier  String     @map("user_identifier") @db.VarChar(255)
  deviceId        String     @map("device_id") @db.VarChar(255)
  changeType      ChangeType @map("change_type")
  tableName       String     @map("table_name") @db.VarChar(255)
  recordId        String     @map("record_id") @db.VarChar(255)
  data            Json       @map("data") @db.JsonB
  clientTimestamp DateTime   @map("client_timestamp") @db.Timestamp()
  clientVersion   Int        @map("client_version")
  createdAt       DateTime   @default(now()) @map("created_at") @db.Timestamp()
  deletedAt       DateTime?  @map("deleted_at") @db.Timestamp()
  device          Device     @relation(fields: [deviceId, userIdentifier], references: [deviceId, userIdentifier])
  appUser         AppUser    @relation(fields: [userIdentifier], references: [userIdentifier])

  @@map("device_changes")
}

model NotificationSettings {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId           String   @unique @map("user_id") @db.Uuid
  marketingEnabled Boolean  @default(true) @map("marketing_enabled")
  emailEnabled     Boolean  @default(true) @map("email_enabled")
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamp()
  updatedAt        DateTime @default(now()) @map("updated_at") @db.Timestamp()
  user             User     @relation(fields: [userId], references: [id])

  @@map("notification_settings")
}

model PasswordResetToken {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  token     String   @unique @db.VarChar(255)
  userId    String   @map("user_id") @db.Uuid
  expiresAt DateTime @map("expires_at") @db.Timestamp()
  user      User     @relation(fields: [userId], references: [id])
  used      Boolean  @default(false)

  @@map("password_reset_tokens")
}

model EmailVerificationToken {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  token     String   @unique @db.VarChar(255)
  userId    String   @map("user_id") @db.Uuid
  expiresAt DateTime @map("expires_at") @db.Timestamp()
  used      Boolean  @default(false)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("email_verification_tokens")
}

model User {
  id                   String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email                String                   @unique @db.VarChar(255)
  passwordHash         String?                  @map("password_hash") @db.VarChar(255)
  firstName            String?                  @map("first_name") @db.VarChar(255)
  lastName             String?                  @map("last_name") @db.VarChar(255)
  avatarUrl            String?                  @map("avatar_url") @db.Text
  isEmailVerified      Boolean                  @default(false) @map("is_email_verified")
  createdAt            DateTime                 @default(now()) @map("created_at") @db.Timestamp()
  updatedAt            DateTime                 @default(now()) @map("updated_at") @db.Timestamp()
  projects             Project[]
  socialConnections    UserSocialConnection[]
  refreshTokens        RefreshToken[]
  projectAuthTokens    ProjectAuthTokens[]
  notificationSettings NotificationSettings?
  passwordResetTokens  PasswordResetToken[]
  emailVerifications   EmailVerificationToken[]

  @@map("users")
}

model OAuthProvider {
  id           String                 @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name         String                 @unique @db.VarChar(50)
  clientId     String                 @map("client_id") @db.VarChar(255)
  clientSecret String                 @map("client_secret") @db.VarChar(255)
  createdAt    DateTime               @default(now()) @map("created_at") @db.Timestamp()
  updatedAt    DateTime               @default(now()) @map("updated_at") @db.Timestamp()
  connections  UserSocialConnection[]

  @@map("oauth_providers")
}

model UserSocialConnection {
  id             String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId         String        @map("user_id") @db.Uuid
  providerId     String        @map("provider_id") @db.Uuid
  providerUserId String        @map("provider_user_id") @db.VarChar(255)
  accessToken    String        @map("access_token") @db.Text
  refreshToken   String?       @map("refresh_token") @db.Text
  tokenExpiresAt DateTime?     @map("token_expires_at") @db.Timestamp()
  providerData   Json?         @map("provider_data") @db.JsonB
  createdAt      DateTime      @default(now()) @map("created_at") @db.Timestamp()
  updatedAt      DateTime      @default(now()) @map("updated_at") @db.Timestamp()
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider       OAuthProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([providerId, providerUserId])
  @@map("user_social_connections")
}

model RefreshToken {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  token     String   @unique @db.VarChar(255)
  expiresAt DateTime @map("expires_at") @db.Timestamp()
  revoked   Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp()
  updatedAt DateTime @default(now()) @map("updated_at") @db.Timestamp()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model ProjectAuthTokens {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  projectId String   @map("project_id") @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  name      String?  @db.VarChar(255)
  token     String   @unique @db.VarChar(255)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp()
  updatedAt DateTime @default(now()) @map("updated_at") @db.Timestamp()
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("auth_tokens")
}
